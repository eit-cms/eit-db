# eit-db v1.0.0 è·¯çº¿å›¾

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

**å®Œå…¨åŸºäº Changeset çš„æ•°æ®åº“æŠ½è±¡å±‚ï¼Œé›¶ GORM æ³„éœ²ï¼ŒMultiple Adapters æ”¯æŒï¼Œç”Ÿäº§çº§åˆ«çš„è¿ç§»å·¥å…·é“¾**

## ğŸ“‹ ç›®æ ‡å¯¹æ¯”

| ç»´åº¦ | v0.2.x (å½“å‰) | v1.0.0 (ç›®æ ‡) |
|------|--------------|--------------|
| CRUD æ¥å£ | éœ€è¦æš´éœ² GORM | å®Œå…¨åŸºäº Changeset |
| äº‹åŠ¡æ”¯æŒ | æœ‰é™ï¼Œç›´æ¥ exec | å®Œæ•´çš„äº‹åŠ¡è¯­ä¹‰ |
| æ‰¹é‡æ“ä½œ | éœ€è¦ GORM | Changeset åŸç”Ÿæ”¯æŒ |
| æ•°æ®åº“æ”¯æŒ | PostgreSQL, MySQL, SQLite | +SQL Server, +è‡ªå®šä¹‰ |
| æ•°æ®æº | å•ä¸€ SQL æ•°æ®åº“ | Multiple Adapters (SQL + æœç´¢å¼•æ“) |
| è¿ç§»å·¥å…· | æ‰‹åŠ¨ç¼–å†™ | å®Œæ•´å·¥å…·é“¾ |
| Schema ç”Ÿæˆ | æ—  | ä»æ•°æ®åº“åå‘ç”Ÿæˆ |
| ç‰ˆæœ¬æ§åˆ¶ | æ—  | è‡ªåŠ¨åˆ†è¡¨ç›‘æ§ |

---

## ğŸ—ï¸ æ ¸å¿ƒä»»åŠ¡

### 1. å®Œå…¨åŸºäº Changeset çš„ CRUD API

#### 1.1 æ ¸å¿ƒåŸåˆ™
- âœ… **ä¸æš´éœ² GORM**ï¼šå°† GORM ä½œä¸ºçº¯ç²¹çš„ driver
- âœ… **äº‹åŠ¡ä¼˜å…ˆ**ï¼šæ‰€æœ‰å†™æ“ä½œé»˜è®¤åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œ
- âœ… **Changeset ä¸­å¿ƒ**ï¼šæ‰€æœ‰æ•°æ®å˜æ›´é€šè¿‡ Changeset éªŒè¯

#### 1.2 æ–°å¢ Repository API

```go
// === æŸ¥è¯¢æ¥å£ ===

// Get æ ¹æ®ä¸»é”®è·å–å•æ¡è®°å½•
func (r *Repository) Get(ctx context.Context, schema Schema, id interface{}) (*Changeset, error)

// GetBy æ ¹æ®æ¡ä»¶è·å–å•æ¡è®°å½•
func (r *Repository) GetBy(ctx context.Context, schema Schema, conditions map[string]interface{}) (*Changeset, error)

// All è·å–æ‰€æœ‰è®°å½•
func (r *Repository) All(ctx context.Context, schema Schema, opts ...QueryOption) ([]*Changeset, error)

// === å†™å…¥æ¥å£ï¼ˆåŸºäº Changesetï¼‰===

// Insert æ’å…¥è®°å½•
func (r *Repository) Insert(ctx context.Context, cs *Changeset, opts ...TxOption) error

// Update æ›´æ–°è®°å½•
func (r *Repository) Update(ctx context.Context, cs *Changeset, opts ...TxOption) error

// Delete åˆ é™¤è®°å½•
func (r *Repository) Delete(ctx context.Context, cs *Changeset, opts ...TxOption) error

// InsertAll æ‰¹é‡æ’å…¥
func (r *Repository) InsertAll(ctx context.Context, changesets []*Changeset, opts ...TxOption) error

// UpdateAll æ‰¹é‡æ›´æ–°ï¼ˆåŸºäºæ¡ä»¶ï¼‰
func (r *Repository) UpdateAll(ctx context.Context, schema Schema, updates map[string]interface{}, conditions map[string]interface{}, opts ...TxOption) (int64, error)

// DeleteAll æ‰¹é‡åˆ é™¤
func (r *Repository) DeleteAll(ctx context.Context, schema Schema, conditions map[string]interface{}, opts ...TxOption) (int64, error)

// === äº‹åŠ¡æ¥å£ ===

// Transaction æ‰§è¡Œäº‹åŠ¡
func (r *Repository) Transaction(ctx context.Context, fn func(tx *Transaction) error, opts ...TxOption) error

// Transaction ç±»å‹
type Transaction struct {
    adapter Tx
    // æä¾›å’Œ Repository ç›¸åŒçš„ CRUD æ–¹æ³•
}
```

#### 1.3 QueryOption å’Œ TxOption

```go
// QueryOption æŸ¥è¯¢é€‰é¡¹
type QueryOption func(*QueryBuilder)

func WithLimit(n int) QueryOption
func WithOffset(n int) QueryOption
func WithOrder(field string, desc bool) QueryOption
func WithSelect(fields ...string) QueryOption
func WithPreload(associations ...string) QueryOption
func WithLock(lockType LockType) QueryOption

// TxOption äº‹åŠ¡é€‰é¡¹
type TxOption func(*TxConfig)

func WithIsolation(level sql.IsolationLevel) TxOption
func WithTimeout(duration time.Duration) TxOption
func WithRetry(maxRetries int) TxOption
func WithSync(adapterNames ...string) TxOption // åŒæ­¥åˆ°å…¶ä»– Adapter
```

#### 1.4 ä½¿ç”¨ç¤ºä¾‹

```go
// æŸ¥è¯¢
user, err := repo.Get(ctx, UserSchema, 123)

users, err := repo.All(ctx, UserSchema, 
    WithLimit(10), 
    WithOrder("created_at", true),
)

// æ’å…¥ï¼ˆåŸºäº Changesetï¼‰
cs := NewChangeset(UserSchema)
cs.Cast(map[string]interface{}{
    "name": "Alice",
    "email": "alice@example.com",
})
cs.ValidateRequired([]string{"name", "email"})

if cs.IsValid() {
    err := repo.Insert(ctx, cs)
}

// äº‹åŠ¡
err := repo.Transaction(ctx, func(tx *Transaction) error {
    // æ’å…¥ç”¨æˆ·
    if err := tx.Insert(ctx, userCS); err != nil {
        return err
    }
    
    // æ›´æ–°ä½™é¢
    _, err := tx.UpdateAll(ctx, AccountSchema, 
        map[string]interface{}{"balance": 100},
        map[string]interface{}{"user_id": userCS.GetChange("id")},
    )
    return err
})
```

#### 1.5 å¤šè¯­å¥æ”¯æŒï¼ˆMySQL ç‰¹æ®Šå¤„ç†ï¼‰

```go
// å¯¹äºéœ€è¦å¤šè¯­å¥çš„åœºæ™¯ï¼Œä½¿ç”¨æ˜¾å¼äº‹åŠ¡
repo.Transaction(ctx, func(tx *Transaction) error {
    // MySQL: ä½¿ç”¨ tx.Exec å¤šæ¬¡æ‰§è¡Œ
    tx.Exec(ctx, "INSERT INTO logs ...")
    tx.Exec(ctx, "UPDATE counters ...")
    return nil
})

// æˆ–ä½¿ç”¨ batch æ¨¡å¼
tx.Batch(ctx, func(b *Batch) error {
    b.Queue("INSERT INTO logs ...")
    b.Queue("UPDATE counters ...")
    return b.Execute() // ä¸€æ¬¡æ€§å‘é€
})
```

---

### 2. å¤šåç«¯æ”¯æŒ

#### 2.1 SQL Server é€‚é…å™¨

**ä¼˜å…ˆçº§**: é«˜

**å®ç°**:
- `sqlserver_adapter.go` - åŸºæœ¬ CRUD
- `sqlserver_dynamic_table.go` - åŠ¨æ€è¡¨æ”¯æŒ
- `sqlserver_migration.go` - è¿ç§»æ”¯æŒ

**å…³é”®å·®å¼‚**:
- TOP è¯­å¥ä»£æ›¿ LIMIT
- IDENTITY ä»£æ›¿ AUTO_INCREMENT
- äº‹åŠ¡éš”ç¦»çº§åˆ«é»˜è®¤å€¼
- å­˜å‚¨è¿‡ç¨‹è¯­æ³•

#### 2.2 è‡ªå®šä¹‰ Adapter æ–‡æ¡£

**æ–‡ä»¶**: `.dev-docs/CUSTOM_ADAPTER.md`

**å†…å®¹**:
```markdown
# è‡ªå®šä¹‰ Adapter æŒ‡å—

## æ”¯æŒéå…³ç³»å‹æ•°æ®åº“

ç±»ä¼¼ Ecto çš„è®¾è®¡ï¼Œeit-db å…è®¸è‡ªå®šä¹‰ Adapter æ¥æ”¯æŒä»»ä½•åç«¯å­˜å‚¨ï¼š

### ç¤ºä¾‹ï¼šMongoDB Adapter

```go
type MongoAdapter struct {
    client *mongo.Client
}

func (a *MongoAdapter) Insert(ctx context.Context, cs *Changeset) error {
    collection := a.client.Database("mydb").Collection(cs.schema.TableName())
    _, err := collection.InsertOne(ctx, cs.GetChanges())
    return err
}
```

### å¿…é¡»å®ç°çš„æ¥å£

1. `Adapter` æ ¸å¿ƒæ¥å£
2. `Tx` äº‹åŠ¡æ¥å£ï¼ˆå¦‚æœæ”¯æŒï¼‰
3. `MigrationAdapter` è¿ç§»æ¥å£ï¼ˆå¯é€‰ï¼‰

### æµ‹è¯•æ¸…å•

- [ ] åŸºæœ¬ CRUD
- [ ] äº‹åŠ¡æ”¯æŒ
- [ ] å¹¶å‘å®‰å…¨
- [ ] é”™è¯¯å¤„ç†

#### 2.3 Adapter æ³¨å†Œæœºåˆ¶

```go
// adapter_registry.go
var adapterRegistry = make(map[string]AdapterFactory)

type AdapterFactory func(config *Config) (Adapter, error)

func RegisterAdapter(name string, factory AdapterFactory) {
    adapterRegistry[name] = factory
}

func GetAdapter(name string, config *Config) (Adapter, error) {
    factory, ok := adapterRegistry[name]
    if !ok {
        return nil, fmt.Errorf("unknown adapter: %s", name)
    }
    return factory(config)
}

// ä½¿ç”¨ç¤ºä¾‹
func init() {
    RegisterAdapter("mongodb", NewMongoAdapter)
    RegisterAdapter("elasticsearch", NewElasticsearchAdapter)
}
```

---

### 3. è¿ç§»å·¥å…·é“¾

#### 3.1 Migration å‘½ä»¤è¡Œå·¥å…·

**æ–‡ä»¶**: `cmd/eit-migrate/main.go`

```bash
# åˆ›å»ºè¿ç§»æ–‡ä»¶
eit-migrate create add_users_table

# æ‰§è¡Œè¿ç§»
eit-migrate up

# å›æ»šè¿ç§»
eit-migrate down

# å›æ»šæ‰€æœ‰è¿ç§»
eit-migrate reset

# æŸ¥çœ‹çŠ¶æ€
eit-migrate status

# ä»æ•°æ®åº“ç”Ÿæˆ schema ä»£ç 
eit-migrate generate schema --table users --output models/user_schema.go
```

#### 3.2 Migration æ–‡ä»¶ç»“æ„

```go
// migrations/20260203120000_add_users_table.go
package migrations

import "github.com/eit-cms/eit-db"

type AddUsersTable struct{}

func (m *AddUsersTable) Up(adapter db.MigrationAdapter) error {
    return adapter.CreateTable("users", func(t *db.TableBuilder) {
        t.BigID("id")
        t.String("name", 100).NotNull()
        t.String("email", 255).Unique().NotNull()
        t.Timestamps()
        t.Index("email")
    })
}

func (m *AddUsersTable) Down(adapter db.MigrationAdapter) error {
    return adapter.DropTable("users")
}

func (m *AddUsersTable) Version() string {
    return "20260203120000"
}
```

#### 3.3 MigrationAdapter æ¥å£

```go
// migration_adapter.go
type MigrationAdapter interface {
    CreateTable(name string, fn func(*TableBuilder)) error
    DropTable(name string) error
    AddColumn(table, name string, columnType ColumnType) error
    DropColumn(table, name string) error
    AddIndex(table string, columns []string, unique bool) error
    DropIndex(table, indexName string) error
    
    // å…ƒæ•°æ®
    GetAppliedMigrations() ([]string, error)
    RecordMigration(version string) error
    RemoveMigration(version string) error
}

// TableBuilder DSL
type TableBuilder struct {
    columns []*ColumnDef
}

func (t *TableBuilder) BigID(name string) *ColumnDef
func (t *TableBuilder) String(name string, length int) *ColumnDef
func (t *TableBuilder) Integer(name string) *ColumnDef
func (t *TableBuilder) Boolean(name string) *ColumnDef
func (t *TableBuilder) Timestamp(name string) *ColumnDef
func (t *TableBuilder) Text(name string) *ColumnDef
func (t *TableBuilder) JSON(name string) *ColumnDef
func (t *TableBuilder) Timestamps() // è‡ªåŠ¨æ·»åŠ  created_at, updated_at
func (t *TableBuilder) Index(columns ...string) *IndexDef
```

#### 3.4 Schema ä»£ç ç”Ÿæˆ

```go
// schema_generator.go

// GenerateSchemaFromTable ä»æ•°æ®åº“è¡¨ç”Ÿæˆ Schema ä»£ç 
func GenerateSchemaFromTable(adapter Adapter, tableName string) (string, error) {
    // 1. æŸ¥è¯¢è¡¨ç»“æ„
    columns, err := adapter.DescribeTable(tableName)
    
    // 2. ç”Ÿæˆä»£ç 
    code := fmt.Sprintf(`
package models

import "github.com/eit-cms/eit-db"

var %sSchema = db.DefineSchema("%s", func(s *db.SchemaBuilder) {
`, toCamelCase(tableName), tableName)
    
    for _, col := range columns {
        code += fmt.Sprintf(`    s.Field("%s", db.%s)`, col.Name, col.Type)
        if col.NotNull {
            code += `.NotNull()`
        }
        code += "\n"
    }
    
    code += "})\n"
    return code, nil
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```bash
# ä»ç°æœ‰æ•°æ®åº“è¡¨ç”Ÿæˆ schema
eit-migrate generate schema --table users --output models/user_schema.go

# ç”Ÿæˆçš„ä»£ç ï¼š
# models/user_schema.go
package models

import "github.com/eit-cms/eit-db"

var UserSchema = db.DefineSchema("users", func(s *db.SchemaBuilder) {
    s.Field("id", db.BigInt).PrimaryKey().AutoIncrement()
    s.Field("name", db.String).NotNull()
    s.Field("email", db.String).NotNull().Unique()
    s.Field("created_at", db.Timestamp).Default("CURRENT_TIMESTAMP")
    s.Field("updated_at", db.Timestamp).Default("CURRENT_TIMESTAMP")
})
```

#### 3.5 Migration çŠ¶æ€ç®¡ç†

```sql
-- schema_migrations è¡¨
CREATE TABLE schema_migrations (
    version VARCHAR(255) PRIMARY KEY,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

### 4. Query Builder å¢å¼º

#### 4.1 æ¡ä»¶æ„å»ºå™¨ (Condition Builder)

```go
// condition.go

// Condition æŸ¥è¯¢æ¡ä»¶æ¥å£
type Condition interface {
    ToSQL() (string, []interface{}, error)
    And(Condition) Condition
    Or(Condition) Condition
    Not() Condition
}

// åŸºç¡€æ¡ä»¶æ„å»ºå‡½æ•°
func Eq(field string, value interface{}) Condition {
    return &eqCondition{field: field, value: value}
}

func NotEq(field string, value interface{}) Condition {
    return &notEqCondition{field: field, value: value}
}

func Gt(field string, value interface{}) Condition {
    return &gtCondition{field: field, value: value}
}

func Gte(field string, value interface{}) Condition {
    return &gteCondition{field: field, value: value}
}

func Lt(field string, value interface{}) Condition {
    return &ltCondition{field: field, value: value}
}

func Lte(field string, value interface{}) Condition {
    return &lteCondition{field: field, value: value}
}

func Like(field string, pattern string) Condition {
    return &likeCondition{field: field, pattern: pattern}
}

func In(field string, values ...interface{}) Condition {
    return &inCondition{field: field, values: values}
}

func NotIn(field string, values ...interface{}) Condition {
    return &notInCondition{field: field, values: values}
}

func IsNull(field string) Condition {
    return &isNullCondition{field: field}
}

func IsNotNull(field string) Condition {
    return &isNotNullCondition{field: field}
}

func Between(field string, min, max interface{}) Condition {
    return &betweenCondition{field: field, min: min, max: max}
}

// ç»„åˆæ¡ä»¶
func And(conditions ...Condition) Condition {
    return &andCondition{conditions: conditions}
}

func Or(conditions ...Condition) Condition {
    return &orCondition{conditions: conditions}
}

func Not(condition Condition) Condition {
    return &notCondition{condition: condition}
}

// ä½¿ç”¨ç¤ºä¾‹
condition := And(
    Eq("status", "active"),
    Or(
        Gt("age", 18),
        Eq("is_verified", true),
    ),
    Not(In("role", "guest", "banned")),
)

users, err := repo.Query(UserSchema).
    Where(condition).
    All(ctx)
```

#### 4.2 é“¾å¼æŸ¥è¯¢ API

```go
// query_builder_v2.go
type Query struct {
    schema     Schema
    conditions Condition
    orders     []Order
    limit      int
    offset     int
    preloads   []string
    groupBy    []string
    having     Condition
    distinct   bool
    forUpdate  bool
}

// æŸ¥è¯¢æ„å»ºå™¨æ–¹æ³•
func (q *Query) Where(condition Condition) *Query {
    if q.conditions == nil {
        q.conditions = condition
    } else {
        q.conditions = And(q.conditions, condition)
    }
    return q
}

func (q *Query) OrWhere(condition Condition) *Query {
    if q.conditions == nil {
        q.conditions = condition
    } else {
        q.conditions = Or(q.conditions, condition)
    }
    return q
}

func (q *Query) Order(field string, desc bool) *Query {
    q.orders = append(q.orders, Order{Field: field, Desc: desc})
    return q
}

func (q *Query) Limit(n int) *Query {
    q.limit = n
    return q
}

func (q *Query) Offset(n int) *Query {
    q.offset = n
    return q
}

func (q *Query) Preload(associations ...string) *Query {
    q.preloads = append(q.preloads, associations...)
    return q
}

func (q *Query) GroupBy(fields ...string) *Query {
    q.groupBy = append(q.groupBy, fields...)
    return q
}

func (q *Query) Having(condition Condition) *Query {
    q.having = condition
    return q
}

func (q *Query) Distinct() *Query {
    q.distinct = true
    return q
}

func (q *Query) ForUpdate() *Query {
    q.forUpdate = true
    return q
}

// æ‰§è¡Œæ–¹æ³•
func (q *Query) All(ctx context.Context) ([]*Changeset, error)
func (q *Query) First(ctx context.Context) (*Changeset, error)
func (q *Query) Count(ctx context.Context) (int64, error)
func (q *Query) Exists(ctx context.Context) (bool, error)
func (q *Query) Pluck(ctx context.Context, field string) ([]interface{}, error)

// ä½¿ç”¨ç¤ºä¾‹ 1: ç®€å•æŸ¥è¯¢
users, err := repo.Query(UserSchema).
    Where(Eq("status", "active")).
    Order("created_at", true).
    Limit(10).
    All(ctx)

// ä½¿ç”¨ç¤ºä¾‹ 2: å¤æ‚æ¡ä»¶
users, err := repo.Query(UserSchema).
    Where(And(
        Eq("status", "active"),
        Or(
            Gt("age", 18),
            Eq("is_verified", true),
        ),
        Not(In("role", "guest", "banned")),
    )).
    Order("created_at", true).
    Limit(10).
    All(ctx)

// ä½¿ç”¨ç¤ºä¾‹ 3: åŠ¨æ€æ¡ä»¶æ„å»º
var conditions []Condition

if age > 0 {
    conditions = append(conditions, Gte("age", age))
}

if status != "" {
    conditions = append(conditions, Eq("status", status))
}

if len(roles) > 0 {
    conditions = append(conditions, In("role", roles...))
}

users, err := repo.Query(UserSchema).
    Where(And(conditions...)).
    All(ctx)

// ä½¿ç”¨ç¤ºä¾‹ 4: èšåˆæŸ¥è¯¢
count, err := repo.Query(UserSchema).
    Where(Eq("status", "active")).
    GroupBy("country").
    Having(Gt("count(*)", 100)).
    Count(ctx)

// ä½¿ç”¨ç¤ºä¾‹ 5: å­æŸ¥è¯¢ï¼ˆé«˜çº§ï¼‰
subQuery := repo.Query(PostSchema).
    Where(Eq("status", "published")).
    Select("user_id")

users, err := repo.Query(UserSchema).
    Where(In("id", subQuery)).
    All(ctx)
```

#### 4.3 æ¡ä»¶å®ç°ç¤ºä¾‹

```go
// eq_condition.go
type eqCondition struct {
    field string
    value interface{}
}

func (c *eqCondition) ToSQL() (string, []interface{}, error) {
    return fmt.Sprintf("%s = ?", c.field), []interface{}{c.value}, nil
}

func (c *eqCondition) And(other Condition) Condition {
    return And(c, other)
}

func (c *eqCondition) Or(other Condition) Condition {
    return Or(c, other)
}

func (c *eqCondition) Not() Condition {
    return Not(c)
}

// and_condition.go
type andCondition struct {
    conditions []Condition
}

func (c *andCondition) ToSQL() (string, []interface{}, error) {
    if len(c.conditions) == 0 {
        return "1=1", nil, nil
    }
    
    var parts []string
    var args []interface{}
    
    for _, cond := range c.conditions {
        sql, condArgs, err := cond.ToSQL()
        if err != nil {
            return "", nil, err
        }
        parts = append(parts, fmt.Sprintf("(%s)", sql))
        args = append(args, condArgs...)
    }
    
    return strings.Join(parts, " AND "), args, nil
}

func (c *andCondition) And(other Condition) Condition {
    return &andCondition{
        conditions: append(c.conditions, other),
    }
}

func (c *andCondition) Or(other Condition) Condition {
    return Or(c, other)
}

func (c *andCondition) Not() Condition {
    return Not(c)
}

// or_condition.go
type orCondition struct {
    conditions []Condition
}

func (c *orCondition) ToSQL() (string, []interface{}, error) {
    if len(c.conditions) == 0 {
        return "1=0", nil, nil
    }
    
    var parts []string
    var args []interface{}
    
    for _, cond := range c.conditions {
        sql, condArgs, err := cond.ToSQL()
        if err != nil {
            return "", nil, err
        }
        parts = append(parts, fmt.Sprintf("(%s)", sql))
        args = append(args, condArgs...)
    }
    
    return strings.Join(parts, " OR "), args, nil
}

func (c *orCondition) And(other Condition) Condition {
    return And(c, other)
}

func (c *orCondition) Or(other Condition) Condition {
    return &orCondition{
        conditions: append(c.conditions, other),
    }
}

func (c *orCondition) Not() Condition {
    return Not(c)
}
```

#### 4.4 å…³è”æŸ¥è¯¢

```go
// å®šä¹‰å…³è”
var UserSchema = DefineSchema("users", func(s *SchemaBuilder) {
    s.Field("id", BigInt).PrimaryKey()
    s.HasMany("posts", PostSchema, "user_id")
    s.HasOne("profile", ProfileSchema, "user_id")
    s.BelongsTo("company", CompanySchema, "company_id")
})

// æŸ¥è¯¢æ—¶é¢„åŠ è½½
users, err := repo.Query(UserSchema).
    Where(Eq("status", "active")).
    Preload("posts", "profile", "company").
    All(ctx)

// é¢„åŠ è½½æ—¶è¿‡æ»¤
users, err := repo.Query(UserSchema).
    Where(Eq("status", "active")).
    PreloadWhere("posts", Eq("status", "published")).
    All(ctx)

// Join æŸ¥è¯¢
users, err := repo.Query(UserSchema).
    Join("posts", Eq("posts.user_id", Raw("users.id"))).
    Where(Eq("posts.status", "published")).
    Distinct().
    All(ctx)
```

#### 4.5 åŸå§‹ SQL æ”¯æŒ

```go
// åŸå§‹ SQL ç‰‡æ®µ
func Raw(sql string, args ...interface{}) Condition {
    return &rawCondition{sql: sql, args: args}
}

// ä½¿ç”¨ç¤ºä¾‹
users, err := repo.Query(UserSchema).
    Where(And(
        Eq("status", "active"),
        Raw("created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)"),
        Or(
            Gt("score", 100),
            Raw("is_premium = true"),
        ),
    )).
    All(ctx)
```

---

### 5. æ•°æ®ç‰ˆæœ¬æ§åˆ¶ä¸è‡ªåŠ¨åˆ†è¡¨ç›‘æ§

> **æ¶æ„å®šä½**: ORM å±‚é¢çš„æ•°æ®ç‰ˆæœ¬ç®¡ç†ï¼ŒåŸºäº Migration å…ƒæ•°æ®è¡¨å®ç°

#### 5.1 ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿè®¾è®¡

```go
// version_control.go

// ç‰ˆæœ¬å…ƒæ•°æ®è¡¨ (ç”± migrator è‡ªåŠ¨ç®¡ç†)
var SchemaVersionsTable = DefineSchema("eit_schema_versions", func(s *SchemaBuilder) {
    s.Field("id", BigInt).PrimaryKey()
    s.Field("table_name", String).NotNull()        // è¢«ç›‘æ§çš„è¡¨å
    s.Field("partition_key", String).Nullable()     // åˆ†è¡¨é”® (å¦‚ "2026_01")
    s.Field("schema_hash", String).NotNull()        // Schema ç»“æ„å“ˆå¸Œ
    s.Field("row_count", BigInt).Default(0)         // å½“å‰è¡Œæ•°
    s.Field("size_bytes", BigInt).Default(0)        // è¡¨å¤§å°
    s.Field("last_modified", Timestamp)             // æœ€åä¿®æ”¹æ—¶é—´
    s.Field("created_at", Timestamp)
    s.UniqueIndex("table_name", "partition_key")
    s.Index("table_name")
})

// å¯ç”¨ç‰ˆæœ¬æ§åˆ¶çš„ Schema
var UserLogsSchema = DefineSchema("user_logs", func(s *SchemaBuilder) {
    s.Field("id", BigInt).PrimaryKey()
    s.Field("user_id", BigInt).NotNull()
    s.Field("action", String)
    s.Field("created_at", Timestamp)
    
    // å¯ç”¨ç‰ˆæœ¬ç›‘æ§å’Œè‡ªåŠ¨åˆ†è¡¨
    s.Versioned(VersionConfig{
        PartitionBy: "month",                    // æŒ‰æœˆåˆ†è¡¨
        PartitionField: "created_at",            // åˆ†è¡¨ä¾æ®å­—æ®µ
        MaxRowsPerPartition: 10000000,           // å•è¡¨æœ€å¤§è¡Œæ•°
        MaxSizePerPartition: 5 * 1024 * 1024 * 1024, // å•è¡¨æœ€å¤§ 5GB
        AutoCreateNextPartition: true,           // è‡ªåŠ¨åˆ›å»ºä¸‹ä¸ªåˆ†åŒº
    })
})

// Repository API
func (r *Repository) EnableVersionControl(ctx context.Context, schema Schema) error {
    // 1. åœ¨ eit_schema_versions ä¸­æ³¨å†Œè¡¨
    // 2. å¯åŠ¨åå°ç›‘æ§
    // 3. æ£€æµ‹ schema å˜æ›´
}

func (r *Repository) GetTableStats(ctx context.Context, tableName string) (*TableStats, error) {
    // è·å–è¡¨çš„ç»Ÿè®¡ä¿¡æ¯
    return &TableStats{
        RowCount:    100000,
        SizeBytes:   1024 * 1024 * 500, // 500MB
        Partitions:  []string{"user_logs_2026_01", "user_logs_2026_02"},
    }, nil
}

func (r *Repository) CreatePartition(ctx context.Context, schema Schema, partitionKey string) error {
    // æ‰‹åŠ¨åˆ›å»ºæ–°åˆ†åŒº
}

// è‡ªåŠ¨åˆ†è¡¨è§¦å‘å™¨ (PostgreSQL)
// å½“æ£€æµ‹åˆ°è¡Œæ•°æˆ–å¤§å°è¶…é™æ—¶ï¼Œè‡ªåŠ¨è§¦å‘åˆ†è¡¨
func (r *Repository) WatchAndPartition(ctx context.Context, schema Schema) error {
    // åå°ç›‘æ§ï¼Œè¾¾åˆ°é˜ˆå€¼æ—¶è‡ªåŠ¨åˆ†è¡¨
}
```

#### 5.2 Migration é›†æˆ

```go
// migration_versioning.go

// Migration è‡ªåŠ¨è®°å½• schema å˜æ›´
type Migration interface {
    Up(adapter MigrationAdapter) error
    Down(adapter MigrationAdapter) error
    Version() string
}

// æ¯æ¬¡ migration æ‰§è¡Œåè‡ªåŠ¨æ›´æ–°ç‰ˆæœ¬è¡¨
func (m *Migrator) Run(migration Migration) error {
    // 1. æ‰§è¡Œ migration
    if err := migration.Up(m.adapter); err != nil {
        return err
    }
    
    // 2. æ›´æ–° eit_schema_versions
    affectedTables := m.getAffectedTables(migration)
    for _, table := range affectedTables {
        m.updateSchemaVersion(table)
    }
    
    // 3. è®°å½•åˆ° schema_migrations
    return m.recordMigration(migration.Version())
}

// æ£€æµ‹ schema å˜æ›´
func (m *Migrator) DetectChanges(ctx context.Context, tableName string) (*SchemaChange, error) {
    currentSchema := m.introspectTable(tableName)
    recordedHash := m.getRecordedHash(tableName)
    
    if currentSchema.Hash() != recordedHash {
        return &SchemaChange{
            Table: tableName,
            Type:  "schema_modified",
            Details: currentSchema.Diff(recordedHash),
        }, nil
    }
    return nil, nil
}
```

---

### 6. Multiple Adapters æ”¯æŒ

> **æ ¸å¿ƒèƒ½åŠ›**: åŒæ—¶ä½¿ç”¨å¤šä¸ªæ•°æ®æºï¼ˆå…³ç³»å‹æ•°æ®åº“ + æœç´¢å¼•æ“ï¼‰

#### 6.1 Multi-Adapter æ¶æ„

```go
// multi_adapter.go

// AdapterType å®šä¹‰é€‚é…å™¨ç±»å‹
type AdapterType string

const (
    AdapterTypeSQL    AdapterType = "sql"    // å…³ç³»å‹æ•°æ®åº“
    AdapterTypeSearch AdapterType = "search" // æœç´¢å¼•æ“
    AdapterTypeCache  AdapterType = "cache"  // ç¼“å­˜ (ä¿ç•™æ¥å£)
)

// MultiRepository æ”¯æŒå¤šä¸ª adapter
type MultiRepository struct {
    primary   Adapter           // ä¸»æ•°æ®æº (SQL)
    secondary map[string]Adapter // è¾…åŠ©æ•°æ®æº
    mu        sync.RWMutex
}

// NewMultiRepository åˆ›å»ºå¤šæ•°æ®æº Repository
func NewMultiRepository(config *MultiConfig) (*MultiRepository, error) {
    repo := &MultiRepository{
        secondary: make(map[string]Adapter),
    }
    
    // ä¸»æ•°æ®æº (å¿…éœ€)
    primary, err := NewAdapter(config.Primary)
    if err != nil {
        return nil, err
    }
    repo.primary = primary
    
    // è¾…åŠ©æ•°æ®æº (å¯é€‰)
    for name, cfg := range config.Secondary {
        adapter, err := NewAdapter(cfg)
        if err != nil {
            return nil, fmt.Errorf("failed to create %s: %w", name, err)
        }
        repo.secondary[name] = adapter
    }
    
    return repo, nil
}

// ä½¿ç”¨ç¤ºä¾‹
config := &MultiConfig{
    Primary: &Config{
        Adapter:  "postgres",
        Host:     "localhost",
        Database: "myapp",
    },
    Secondary: map[string]*Config{
        "search": {
            Adapter: "elasticsearch",
            Hosts:   []string{"http://localhost:9200"},
        },
        "analytics": {
            Adapter: "clickhouse",
            Host:    "localhost",
            Database: "analytics",
        },
    },
}

repo, err := NewMultiRepository(config)

// å†™å…¥ä¸»æ•°æ®æºï¼ŒåŒæ­¥åˆ°æœç´¢å¼•æ“
err = repo.Insert(ctx, articleCS, WithSync("search"))

// ä»æœç´¢å¼•æ“æŸ¥è¯¢
results, _ := repo.SearchOn(ctx, "search", ArticleSchema, "golang database")

// ä»ä¸»æ•°æ®æºæŸ¥è¯¢
article, _ := repo.Get(ctx, ArticleSchema, 123)
```

#### 6.2 æœç´¢å¼•æ“ Adapter

```go
// search_adapter.go

// SearchAdapter æœç´¢å¼•æ“é€‚é…å™¨æ¥å£
type SearchAdapter interface {
    Adapter // ç»§æ‰¿åŸºç¡€æ¥å£
    
    // æœç´¢ç‰¹å®šæ–¹æ³•
    Index(ctx context.Context, indexName string, doc map[string]interface{}) error
    Search(ctx context.Context, indexName string, query *SearchQuery) (*SearchResult, error)
    Delete(ctx context.Context, indexName string, id interface{}) error
    BulkIndex(ctx context.Context, indexName string, docs []map[string]interface{}) error
    
    // ç´¢å¼•ç®¡ç†
    CreateIndex(ctx context.Context, indexName string, mapping map[string]interface{}) error
    DeleteIndex(ctx context.Context, indexName string) error
    IndexExists(ctx context.Context, indexName string) (bool, error)
}

// SearchQuery æœç´¢æŸ¥è¯¢
type SearchQuery struct {
    Query      string
    Fields     []string
    Filters    map[string]interface{}
    Sort       []SortField
    From       int
    Size       int
    Highlight  bool
}

// SearchResult æœç´¢ç»“æœ
type SearchResult struct {
    Total      int64
    Hits       []map[string]interface{}
    Took       int64 // æŸ¥è¯¢è€—æ—¶ (ms)
    MaxScore   float64
}
```

#### 6.3 Elasticsearch Adapter

```go
// elasticsearch_adapter.go

type ElasticsearchAdapter struct {
    client *elasticsearch.Client
    config *Config
}
å‡½æ•°å¼æ¡ä»¶æ„å»ºå™¨
repo.Query(UserSchema).
    Where(And(
        Eq("status", "active"),
        Or(Gt("age", 18), Eq("is_verified", true)),
        Not(In("role", "guest", "banned")),
    ).Config{
        Addresses: config.Hosts,
        Username:  config.Username,
        Password:  config.Password,
    }
    
    client, err := elasticsearch.NewClient(cfg)
    if err != nil {
        return nil, err
    }
    
    return &ElasticsearchAdapter{
        client: client,
        config: config,
    }, nil
}

func (a *ElasticsearchAdapter) Search(ctx context.Context, indexName string, query *SearchQuery) (*SearchResult, error) {
    // æ„å»º ES æŸ¥è¯¢
    esQuery := map[string]interface{}{
        "query": map[string]interface{}{
            "multi_match": map[string]interface{}{
                "query":  query.Query,
                "fields": query.Fields,
            },
        },
        "from": query.From,
        "size": query.Size,
    }
    
    // æ‰§è¡Œæœç´¢
    res, err := a.client.Search(
        a.client.Search.WithContext(ctx),
        a.client.Search.WithIndex(indexName),
        a.client.Search.WithBody(esReader(esQuery)),
    )
    if err != nil {
        return nil, err
    }
    defer res.Body.Close()
    
    // è§£æç»“æœ
    return parseESResponse(res)
}

func (a *ElasticsearchAdapter) Index(ctx context.Context, indexName string, doc map[string]interface{}) error {
    // ç´¢å¼•æ–‡æ¡£
    data, _ := json.Marshal(doc)
    res, err := a.client.Index(
        indexName,
        bytes.NewReader(data),
        a.client.Index.WithContext(ctx),
    )
    if err != nil {
        return err
    }
    defer res.Body.Close()
    
    return checkESError(res)
}
```

#### 6.4 Meilisearch Adapter

```go
// meilisearch_adapter.go

type MeilisearchAdapter struct {
    client *meilisearch.Client
    config *Config
}

func NewMeilisearchAdapter(config *Config) (*MeilisearchAdapter, error) {
    client := meilisearch.NewClient(meilisearch.ClientConfig{
        Host:   config.Host,
        APIKey: config.APIKey,
    })
    
    return &MeilisearchAdapter{
        client: client,
        config: config,
    }, nil
}

func (a *MeilisearchAdapter) Search(ctx context.Context, indexName string, query *SearchQuery) (*SearchResult, error) {
    index := a.client.Index(indexName)
    
    res, err := index.Search(query.Query, &meilisearch.SearchRequest{
        AttributesToRetrieve: query.Fields,
        Limit:                int64(query.Size),
        Offset:               int64(query.From),
    })
    if err != nil {
        return nil, err
    }
    
    return &SearchResult{
        Total: res.EstimatedTotalHits,
        Hits:  convertMeiliHits(res.Hits),
        Took:  res.ProcessingTimeMs,
    }, nil
}
```

#### 6.5 æ•°æ®åŒæ­¥ç­–ç•¥

```go
// sync.go

// SyncStrategy åŒæ­¥ç­–ç•¥
type SyncStrategy string

const (
    SyncStrategyImmediate SyncStrategy = "immediate" // ç«‹å³åŒæ­¥
    SyncStrategyAsync     SyncStrategy = "async"     // å¼‚æ­¥åŒæ­¥
    SyncStrategyBatch     SyncStrategy = "batch"     // æ‰¹é‡åŒæ­¥
)

// WithSync é€‰é¡¹
func WithSync(adapterNames ...string) TxOption {
    return func(cfg *TxConfig) {
        cfg.SyncTo = adapterNames
        cfg.SyncStrategy = SyncStrategyImmediate
    }
}

// Repository å®ç°
func (r *MultiRepository) Insert(ctx context.Context, cs *Changeset, opts ...TxOption) error {
    cfg := &TxConfig{}
    for _, opt := range opts {
        opt(cfg)
    }
    
    // 1. å†™å…¥ä¸»æ•°æ®æº
    if err := r.primary.Insert(ctx, cs); err != nil {
        return err
    }
    
    // 2. åŒæ­¥åˆ°è¾…åŠ©æ•°æ®æº
    if len(cfg.SyncTo) > 0 {
        return r.syncToSecondary(ctx, cs, cfg.SyncTo, cfg.SyncStrategy)
    }
    
    return nil
}

func (r *MultiRepository) syncToSecondary(ctx context.Context, cs *Changeset, targets []string, strategy SyncStrategy) error {
    for _, name := range targets {
        adapter, ok := r.secondary[name]
        if !ok {
            continue
        }
        
        switch strategy {
        case SyncStrategyImmediate:
            if err := r.syncImmediate(ctx, adapter, cs); err != nil {
                return err
            }
        case SyncStrategyAsync:
            go r.syncAsync(context.Background(), adapter, cs)
        case SyncStrategyBatch:
            r.queueForBatch(adapter, cs)
        }
    }
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleMultiAdapter() {
    // æ’å…¥æ–‡ç« ï¼ŒåŒæ­¥åˆ° Elasticsearch
    articleCS := NewChangeset(ArticleSchema)
    articleCS.Cast(map[string]interface{}{
        "title":   "Go Database Design",
        "content": "This is a comprehensive guide...",
    })
    
    err := repo.Insert(ctx, articleCS, WithSync("search"))
    
    // ä» Elasticsearch æœç´¢
    results, _ := repo.SearchOn(ctx, "search", ArticleSchema, "database design")
    
    // ä» PostgreSQL æŸ¥è¯¢è¯¦æƒ…
    for _, result := range results.Hits {
        id := result["id"]
        article, _ := repo.Get(ctx, ArticleSchema, id)
        fmt.Println(article)
    }
}
```

---

### 7. æ—¥å¿—å’Œè¿½è¸ª

```go
// logger.go
type Logger interface {
    LogQuery(query string, args []interface{}, duration time.Duration)
    LogError(err error, context map[string]interface{})
    LogSync(adapter string, operation string, duration time.Duration)
}

// åœ¨é…ç½®ä¸­å¯ç”¨
config := &Config{
    Logger: NewZapLogger(),
    LogLevel: LogLevelDebug,
}

// è¾“å‡ºç¤ºä¾‹ï¼š
// [DEBUG] SQL: SELECT * FROM users WHERE id = ? [123] (2.3ms)
// [DEBUG] Syncing to Elasticsearch: articles/123 (15ms)
// [DEBUG] Search: "golang database" in articles (45ms, 1234 hits)
```

### 8. æ€§èƒ½ä¼˜åŒ–

#### 8.1 è¿æ¥æ± ç›‘æ§

```go
func (r *Repository) Stats() *Stats {
    return &Stats{
        OpenConnections: r.adapter.Stats().OpenConnections,
        IdleConnections: r.adapter.Stats().Idle,
        WaitDuration:    r.adapter.Stats().WaitDuration,
    }
}
```

#### 8.2 Prepared Statement ç¼“å­˜

```go
type PreparedStmtCache struct {
    cache map[string]*sql.Stmt
    mu    sync.RWMutex
}
```

### 9. æµ‹è¯•å·¥å…·

```go
// testing.go

// SetupTestDB åˆ›å»ºæµ‹è¯•æ•°æ®åº“
func SetupTestDB(t *testing.T) *Repository {
    config := &Config{
        Adapter:  "postgres",
        Database: "test_db_" + randomString(),
    }
    repo, err := NewRepository(config)
    require.NoError(t, err)
    
    t.Cleanup(func() {
        repo.Close()
        dropTestDB(config.Database)
    })
    
    return repo
}

// Factory å·¥å‚å‡½æ•°
func Factory(schema Schema, overrides map[string]interface{}) *Changeset {
    defaults := getDefaults(schema)
    for k, v := range overrides {
        defaults[k] = v
    }
    return FromMap(schema, defaults)
}
```

---

## ğŸ“¦ ç‰ˆæœ¬é‡Œç¨‹ç¢‘

### v0æ¡ä»¶æ„å»ºå™¨ (Eq, Gt, Lt, In, And, Or, Not ç­‰)
- [x] æ¡ä»¶æ„å»ºå™¨ (Eq, Gt, Lt, In, And, Or, Not ç­‰)
- [x] Query Builder é“¾å¼ API
- [ ] å…³è”æŸ¥è¯¢å’Œé¢„åŠ è½½
- [ ] èšåˆæŸ¥è¯¢ (Count, GroupBy, Having)é¢„è®¡ 2 å‘¨)
- [ ] æ–°çš„ Repository CRUD API
- [ ] å®Œæ•´çš„äº‹åŠ¡æ”¯æŒ
- [ ] ç§»é™¤æ‰€æœ‰ GORM æš´éœ²
- [ ] Query Builder å¢å¼º

### v0.4.0 - SQL Server æ”¯æŒ (é¢„è®¡ 1 å‘¨)
- [x] SQL Server Adapter
- [x] åŠ¨æ€è¡¨æ”¯æŒ
- [x] æµ‹è¯•è¦†ç›–

### v0.5.0 - è¿ç§»å·¥å…·åŸºç¡€ (é¢„è®¡ 2 å‘¨)
- [x] Migration æ–‡ä»¶ç»“æ„
- [ ] MigrationAdapter æ¥å£
- [x] åŸºæœ¬å‘½ä»¤è¡Œå·¥å…·

### v0.6.0 - è¿ç§»å·¥å…·å®Œå–„ (é¢„è®¡ 1 å‘¨)
- [ ] Schema ä»£ç ç”Ÿæˆ
- [x] è¿ç§»çŠ¶æ€ç®¡ç†
- [x] å›æ»šæœºåˆ¶

### v0.7.0 - è‡ªå®šä¹‰ Adapter (é¢„è®¡ 1 å‘¨)
- [ ] Adapter æ³¨å†Œæœºåˆ¶
- [ ] å®Œæ•´æ–‡æ¡£å’Œç¤ºä¾‹
- [ ] MongoDB Adapter ç¤ºä¾‹

### v0.8.0 - æ•°æ®ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿ (é¢„è®¡ 2 å‘¨)
- [ ] Schema ç‰ˆæœ¬å…ƒæ•°æ®è¡¨è®¾è®¡
- [ ] è‡ªåŠ¨ç›‘æ§è¡¨å¤§å°å’Œè¡Œæ•°
- [ ] åˆ†è¡¨ç­–ç•¥å’Œè‡ªåŠ¨è§¦å‘
- [ ] Migration é›†æˆ
- [ ] Schema å˜æ›´æ£€æµ‹
- [ ] åˆ†åŒºç®¡ç† API

### v0.9.0 - Multiple Adapters æ”¯æŒ (é¢„è®¡ 2 å‘¨)
- [ ] Multi-Adapter æ¶æ„è®¾è®¡
- [ ] SearchAdapter æ¥å£å®šä¹‰
- [ ] Elasticsearch Adapter å®ç°
- [ ] Meilisearch Adapter å®ç°
- [ ] æ•°æ®åŒæ­¥ç­–ç•¥ï¼ˆç«‹å³/å¼‚æ­¥/æ‰¹é‡ï¼‰
- [ ] å…±äº« Schema åŸºçº¿ï¼ˆå¤š Adapter ç»Ÿä¸€ Schema å®šä¹‰ä¸å˜æ›´å…¥å£ï¼‰
- [ ] Migrator å¤š Adapter ä¸€è‡´æ€§æ ¡éªŒï¼ˆSchema Hash / æ•°æ®ä¸€è‡´æ€§ç­–ç•¥ï¼‰
- [ ] Adapter æ³¨å†Œå’Œå‘ç°æœºåˆ¶

### v0.10.0 - æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§ (é¢„è®¡ 1 å‘¨)
- [ ] æ—¥å¿—è¿½è¸ªç³»ç»Ÿ
- [ ] æ€§èƒ½ç›‘æ§æŒ‡æ ‡
- [ ] è¿æ¥æ± ä¼˜åŒ–
- [ ] Prepared Statement ç¼“å­˜
- [ ] æ…¢æŸ¥è¯¢åˆ†æ

### v0.11.0 - æµ‹è¯•å’Œæ–‡æ¡£ (é¢„è®¡ 1 å‘¨)
- [ ] å®Œæ•´æµ‹è¯•å¥—ä»¶
- [ ] Multi-Adapter é›†æˆæµ‹è¯•
- [ ] API æ–‡æ¡£
- [ ] æœç´¢å¼•æ“é›†æˆç¤ºä¾‹

### v1.0.0 - æ­£å¼å‘å¸ƒ (é¢„è®¡ 1 å‘¨)
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•
- [ ] å®‰å…¨å®¡è®¡
- [ ] å‘å¸ƒæ–‡æ¡£

---

## ğŸ’¡ åŠŸèƒ½ä¼˜å…ˆçº§ï¼ˆORM æ¶æ„å±‚é¢ï¼‰

### 1. **å®Œå…¨åŸºäº Changeset çš„ CRUD** (é‡è¦åº¦: â­â­â­â­â­)
```go
// é›¶ GORM æ³„éœ²ï¼Œå®Œæ•´äº‹åŠ¡æ”¯æŒ
repo.Insert(ctx, cs)
repo.Transaction(ctx, func(tx *Transaction) error {
    // ...
})
```

### 2. **Query Builder å¢å¼º** (é‡è¦åº¦: â­â­â­â­â­)
```go
// é“¾å¼æŸ¥è¯¢ï¼Œé¿å…æ‰‹å†™ SQL
repo.Query(UserSchema).
    Where("age", ">", 18).
    Order("created_at", true).
    Limit(10).
    All(ctx)
```

### 3. **Multiple Adapters æ”¯æŒ** (é‡è¦åº¦: â­â­â­â­â­)
```go
// åŒæ—¶ä½¿ç”¨ PostgreSQL + Elasticsearch
repo := NewMultiRepository(config)
repo.Insert(ctx, cs, WithSync("search"))
results, _ := repo.SearchOn(ctx, "search", ArticleSchema, "golang")
```

### 4. **æ•°æ®ç‰ˆæœ¬æ§åˆ¶ä¸è‡ªåŠ¨åˆ†è¡¨** (é‡è¦åº¦: â­â­â­â­)
```go
// åŸºäº Migration çš„è‡ªåŠ¨åˆ†è¡¨ç›‘æ§
s.Versioned(VersionConfig{
    PartitionBy: "month",
    MaxRowsPerPartition: 10000000,
})
```

### 5. **å®Œæ•´çš„è¿ç§»å·¥å…·é“¾** (é‡è¦åº¦: â­â­â­â­â­)
```bash
# ä»åˆ›å»ºåˆ°æ‰§è¡Œåˆ°å›æ»š
eit-migrate create add_users
eit-migrate up
eit-migrate down
eit-migrate generate schema --table users
```

### 6. **å…³è”æŸ¥è¯¢æ”¯æŒ** (é‡è¦åº¦: â­â­â­â­)
```go
// ç±»ä¼¼ Ecto çš„ preload
users, _ := repo.All(ctx, UserSchema, WithPreload("posts"))
```

### 7. **æ—¥å¿—å’Œè¿½è¸ª** (é‡è¦åº¦: â­â­â­â­â­)
```go
// å¼€å‘æ—¶çœ‹åˆ°æ‰€æœ‰ SQL
[DEBUG] SQL: SELECT * FROM users WHERE id = ? [123] (2.3ms)
[DEBUG] Syncing to Elasticsearch: articles/123
```

### 8. **æµ‹è¯•å·¥å…·** (é‡è¦åº¦: â­â­â­â­)
```go
// ç®€åŒ–æµ‹è¯•
repo := SetupTestDB(t)
user := Factory(UserSchema, {"name": "test"})
```

### 9. **SQL Server æ”¯æŒ** (é‡è¦åº¦: â­â­â­)
```go
// å®Œæ•´çš„ä¼ä¸šçº§æ•°æ®åº“æ”¯æŒ
config := &Config{Adapter: "sqlserver", ...}
```

### 10. **è‡ªå®šä¹‰ Adapter æœºåˆ¶** (é‡è¦åº¦: â­â­â­â­)
```go
// æ³¨å†Œè‡ªå®šä¹‰ Adapter
RegisterAdapter("mongodb", NewMongoAdapter)
RegisterAdapter("clickhouse", NewClickhouseAdapter)
```

---

## ğŸ“… æ—¶é—´è§„åˆ’

- **v0.3.0 - CRUD é‡æ„**: 2 å‘¨ (æœ€æ ¸å¿ƒ)
- **v0.4.0 - SQL Server**: 1 å‘¨
- **v0.5.0-0.6.0 - è¿ç§»å·¥å…·**: 3 å‘¨
- **v0.7.0 - è‡ªå®šä¹‰ Adapter**: 1 å‘¨
- **v0.8.0 - æ•°æ®ç‰ˆæœ¬æ§åˆ¶**: 2 å‘¨ (é‡ç‚¹)
- **v0.9.0 - Multiple Adapters**: 2 å‘¨ (é‡ç‚¹)
- **v0.10.0-0.11.0 - å®Œå–„**: 2 å‘¨
- **v1.0.0 - å‘å¸ƒ**: 1 å‘¨

**æ€»è®¡**: çº¦ 13 å‘¨ (3 ä¸ªæœˆ)

---

## ğŸ¯ æˆåŠŸæ ‡å‡†

1. **é›¶ GORM æ³„éœ²**: åº”ç”¨å±‚å®Œå…¨ä¸éœ€è¦å¯¼å…¥ GORM
2. **å®Œæ•´äº‹åŠ¡**: æ‰€æœ‰å†™æ“ä½œæ”¯æŒäº‹åŠ¡å’Œå›æ»š
3. **å¤šæ•°æ®åº“**: PostgreSQL, MySQL, SQLite, SQL Server å…¨æ”¯æŒ
4. **è¿ç§»å·¥å…·**: ä»åˆ›å»ºåˆ°æ‰§è¡Œåˆ°å›æ»šçš„å®Œæ•´å·¥å…·é“¾
5. **ä»£ç ç”Ÿæˆ**: ä»æ•°æ®åº“è‡ªåŠ¨ç”Ÿæˆ Schema ä»£ç 
6. **ç‰ˆæœ¬æ§åˆ¶**: åŸºäº Migration çš„è‡ªåŠ¨åˆ†è¡¨ç›‘æ§ç³»ç»Ÿ
7. **Multiple Adapters**: åŒæ—¶ä½¿ç”¨å…³ç³»å‹æ•°æ®åº“å’Œæœç´¢å¼•æ“
8. **æœç´¢å¼•æ“**: Elasticsearchã€Meilisearch åŸç”Ÿæ”¯æŒ
9. **ç”Ÿäº§å°±ç»ª**: æ—¥å¿—ã€ç›‘æ§ã€é”™è¯¯å¤„ç†å®Œå–„
10. **æµ‹è¯•è¦†ç›–**: 90%+ ä»£ç è¦†ç›–ç‡
11. **æ–‡æ¡£å®Œæ•´**: API æ–‡æ¡£ã€ä½¿ç”¨æŒ‡å—ã€Multi-Adapter æœ€ä½³å®è·µ

---

## ğŸ¨ ä¸ eit-cms ç”Ÿæ€é›†æˆ

### æ˜ç¡®çš„èŒè´£åˆ’åˆ†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              eit-cms (Application)                 â”‚
â”‚  - ä¸šåŠ¡é€»è¾‘                                         â”‚
â”‚  - HTTP è·¯ç”±                                        â”‚
â”‚  - è®¤è¯æˆæƒ                                         â”‚
â”‚  - è½¯åˆ é™¤é€»è¾‘ (åº”ç”¨å±‚å®ç°)                          â”‚
â”‚  - å†…å®¹çŠ¶æ€å·¥ä½œæµ                                   â”‚
â”‚  - å¤šè¯­è¨€å†…å®¹ç®¡ç†                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              eit-cache (Caching)                   â”‚
â”‚  - Redis ç¼“å­˜                                       â”‚
â”‚  - Session ç®¡ç†                                     â”‚
â”‚  - ç¼“å­˜ç­–ç•¥                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              eit-db (ORM + Data Layer)             â”‚
â”‚  - æ•°æ®æŒä¹…åŒ– (PostgreSQL/MySQL/SQLite/SQL Server) â”‚
â”‚  - Schema å®šä¹‰å’ŒéªŒè¯ (Changeset)                   â”‚
â”‚  - äº‹åŠ¡ç®¡ç†                                         â”‚
â”‚  - æ•°æ®ç‰ˆæœ¬æ§åˆ¶å’Œè‡ªåŠ¨åˆ†è¡¨                           â”‚
â”‚  - Multiple Adapters æ”¯æŒ                          â”‚
â”‚  - æœç´¢å¼•æ“é›†æˆ (Elasticsearch/Meilisearch)        â”‚
â”‚  - åŠ¨æ€è¡¨/å®šæ—¶ä»»åŠ¡                                  â”‚
â”‚  - è¿ç§»å·¥å…·é“¾                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### åä½œç¤ºä¾‹

```go
// eit-cms åº”ç”¨å±‚ä»£ç 
func (s *ArticleService) PublishArticle(ctx context.Context, id int64) error {
    // 1. ä»æ•°æ®åº“è·å–ï¼ˆeit-db - PostgreSQLï¼‰
    article, err := s.repo.Get(ctx, ArticleSchema, id)
    if err != nil {
        return err
    }
    
    // 2. æ›´æ–°çŠ¶æ€ï¼ˆåº”ç”¨å±‚é€»è¾‘ï¼Œeit-cms è´Ÿè´£ï¼‰
    cs := FromMap(ArticleSchema, map[string]interface{}{
        "id":           id,
        "status":       "published",
        "published_at": time.Now(),
    })
    
    // 3. ä¿å­˜å¹¶åŒæ­¥åˆ°æœç´¢å¼•æ“ï¼ˆeit-db çš„ Multi-Adapter èƒ½åŠ›ï¼‰
    if err := s.repo.Update(ctx, cs, WithSync("search")); err != nil {
        return err
    }
    
    // 4. æ¸…é™¤ç¼“å­˜ï¼ˆeit-cacheï¼‰
    s.cache.Delete(fmt.Sprintf("article:%d", id))
    
    // 5. é¢„çƒ­ç¼“å­˜ï¼ˆeit-cacheï¼‰
    s.cache.Set(fmt.Sprintf("article:%d", id), article, 1*time.Hour)
    
    return nil
}

// æœç´¢æ–‡ç« ï¼ˆeit-db - Elasticsearchï¼‰
func (s *ArticleService) SearchArticles(ctx context.Context, keyword string) ([]Article, error) {
    // ä» Elasticsearch æœç´¢
    results, err := s.repo.SearchOn(ctx, "search", ArticleSchema, keyword)
    if err != nil {
        return nil, err
    }
    
    // ä» PostgreSQL è·å–å®Œæ•´æ•°æ®
    var articles []Article
    for _, hit := range results.Hits {
        id := hit["id"].(int64)
        article, _ := s.repo.Get(ctx, ArticleSchema, id)
        articles = append(articles, article)
    }
    
    return articles, nil
}
```

### eit-db ä¸è´Ÿè´£çš„å†…å®¹ï¼ˆåº”ç”¨å±‚å…³æ³¨ç‚¹ï¼‰

- âŒ HTTP ç¼“å­˜ï¼ˆç”± eit-cache å¤„ç†ï¼‰
- âŒ ä¼šè¯ç®¡ç†ï¼ˆç”± eit-cache å¤„ç†ï¼‰
- âŒ ä¸šåŠ¡é€»è¾‘éªŒè¯ï¼ˆç”± eit-cms å¤„ç†ï¼‰
- âŒ API é™æµï¼ˆç”± eit-cms å¤„ç†ï¼‰
- âŒ è½¯åˆ é™¤é€»è¾‘ï¼ˆåº”ç”¨å±‚å®ç°ï¼Œåªéœ€åœ¨ schema ä¸­å®šä¹‰ deleted_at å­—æ®µï¼‰
- âŒ å†…å®¹çŠ¶æ€å·¥ä½œæµï¼ˆåº”ç”¨å±‚å»ºè¡¨æ—¶å®šä¹‰ status å­—æ®µï¼‰
- âŒ å¤šè¯­è¨€å†…å®¹ç»“æ„ï¼ˆåº”ç”¨å±‚å»ºè¡¨è€ƒè™‘ï¼Œorm åªè´Ÿè´£æŒä¹…åŒ–ï¼‰
- âŒ åª’ä½“æ–‡ä»¶å¤„ç†ï¼ˆéœ€è¦ç‹¬ç«‹çš„æ–‡ä»¶ç®¡ç†åº“ï¼‰
- âŒ å¤šç§Ÿæˆ·é€»è¾‘ï¼ˆMySQL/SQLite åœ¨åº”ç”¨å±‚å®ç°ï¼ŒPG/SQL Server ä½¿ç”¨ä¸“é—¨æ–¹æ¡ˆï¼‰

### eit-db ä¸“æ³¨çš„å†…å®¹ï¼ˆORM æ¶æ„å±‚é¢ï¼‰

- âœ… æ•°æ®åº“è¿æ¥å’ŒæŸ¥è¯¢ï¼ˆå¤šæ•°æ®åº“æ”¯æŒï¼‰
- âœ… Schema å®šä¹‰å’ŒéªŒè¯ï¼ˆChangesetï¼‰
- âœ… äº‹åŠ¡ç®¡ç†å’Œå›æ»š
- âœ… æ•°æ®åº“è¿ç§»å·¥å…·é“¾
- âœ… æ•°æ®ç‰ˆæœ¬æ§åˆ¶å’Œè‡ªåŠ¨åˆ†è¡¨ç›‘æ§ï¼ˆåŸºäº Migration å…ƒæ•°æ®ï¼‰
- âœ… Multiple Adapters æ”¯æŒï¼ˆåŒæ—¶ä½¿ç”¨ SQL + æœç´¢å¼•æ“ï¼‰
- âœ… æœç´¢å¼•æ“é›†æˆï¼ˆElasticsearchã€Meilisearchï¼‰
- âœ… æ•°æ®åŒæ­¥ç­–ç•¥ï¼ˆç«‹å³/å¼‚æ­¥/æ‰¹é‡ï¼‰
- âœ… åŠ¨æ€è¡¨åˆ›å»ºå’Œç®¡ç†
- âœ… å®šæ—¶æ•°æ®åº“ä»»åŠ¡ï¼ˆå¦‚æŒ‰æœˆå»ºè¡¨ï¼‰
- âœ… æ€§èƒ½ç›‘æ§å’Œæ—¥å¿—è¿½è¸ª

---

## ğŸ¤” æ¶æ„è®¾è®¡è€ƒé‡

### å…³äº GORM çš„å®šä½

**å½“å‰é—®é¢˜**: 
- éƒ¨åˆ†åŠŸèƒ½ç›´æ¥æš´éœ² GORM (GetGormDB)
- ä¸šåŠ¡å±‚å¯èƒ½ç›´æ¥è°ƒç”¨ GORM API

**1.0 è§£å†³æ–¹æ¡ˆ**:
```go
// âŒ ä¸å†æä¾›
// func (r *Repository) GetGormDB() *gorm.DB

// âœ… GORM å®Œå…¨éšè—åœ¨ adapter å†…éƒ¨
type gormAdapter struct {
    db *gorm.DB // ç§æœ‰ï¼Œå¤–éƒ¨ä¸å¯è®¿é—®
}

// âœ… æ‰€æœ‰åŠŸèƒ½é€šè¿‡ Adapter æ¥å£æš´éœ²
func (a *gormAdapter) Insert(ctx context.Context, cs *Changeset) error {
    // å†…éƒ¨ä½¿ç”¨ GORMï¼Œå¤–éƒ¨æ— æ„ŸçŸ¥
    return a.db.Create(cs.GetChanges()).Error
}
```

### å…³äºäº‹åŠ¡çš„è®¾è®¡

**ç­–ç•¥**:
1. **é»˜è®¤äº‹åŠ¡**: æ‰€æœ‰å†™æ“ä½œè‡ªåŠ¨åŒ…è£…åœ¨äº‹åŠ¡ä¸­
2. **æ˜¾å¼äº‹åŠ¡**: æ”¯æŒæ‰‹åŠ¨ç®¡ç†äº‹åŠ¡è¾¹ç•Œ
3. **åµŒå¥—äº‹åŠ¡**: ä½¿ç”¨ Savepoint å®ç°ï¼ˆPostgreSQLï¼‰

```go
// è‡ªåŠ¨äº‹åŠ¡ï¼ˆæ¨èï¼‰
err := repo.Insert(ctx, cs) // è‡ªåŠ¨åŒ…è£…äº‹åŠ¡

// æ˜¾å¼äº‹åŠ¡ï¼ˆå¤šæ­¥éª¤ï¼‰
err := repo.Transaction(ctx, func(tx *Transaction) error {
    tx.Insert(ctx, userCS)
    tx.Update(ctx, profileCS)
    return nil
})
```

### å…³äº MySQL å¤šè¯­å¥

**é—®é¢˜**: MySQL é»˜è®¤ä¸æ”¯æŒå•æ¬¡æ‰§è¡Œå¤šæ¡è¯­å¥

**è§£å†³æ–¹æ¡ˆ**:
1. **å®¢æˆ·ç«¯æ‹¼æ¥**: åœ¨äº‹åŠ¡ä¸­å¤šæ¬¡ Exec
2. **Batch æ¨¡å¼**: ä½¿ç”¨ prepared statement + executemany
3. **å­˜å‚¨è¿‡ç¨‹**: å¯¹äºå¤æ‚é€»è¾‘ï¼Œä½¿ç”¨å­˜å‚¨è¿‡ç¨‹

```go
// æ–¹æ¡ˆ1: å¤šæ¬¡ Execï¼ˆæ¨èï¼‰
tx.Exec(ctx, "INSERT INTO logs ...")
tx.Exec(ctx, "UPDATE counters ...")

// æ–¹æ¡ˆ2: Batch æ¨¡å¼
tx.Batch(ctx, func(b *Batch) error {
    b.Queue("INSERT ...")
    b.Queue("UPDATE ...")
    return b.Execute()
})

// æ–¹æ¡ˆ3: å­˜å‚¨è¿‡ç¨‹
tx.Exec(ctx, "CALL process_data(?)", userId)
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [Ecto Repo API](https://hexdocs.pm/ecto/Ecto.Repo.html)
- [Ecto Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html)
- [Ecto Migrations](https://hexdocs.pm/ecto_sql/Ecto.Migration.html)
- [GORM Documentation](https://gorm.io/docs/)
- [database/sql Best Practices](https://go.dev/doc/database/querying)
- [Elasticsearch Go Client](https://github.com/elastic/go-elasticsearch)
- [Meilisearch Go SDK](https://github.com/meilisearch/meilisearch-go)

---

**è§„åˆ’åˆ¶å®šæ—¥æœŸ**: 2026å¹´2æœˆ3æ—¥  
**é¢„è®¡å®Œæˆæ—¥æœŸ**: 2026å¹´5æœˆåˆ  
**çŠ¶æ€**: å¾…å®¡æ‰¹

---

## ğŸ“Œ é™„å½•ï¼šæ¶æ„å†³ç­–è®°å½• (ADR)

### ADR-001: ä¸ºä»€ä¹ˆä¸åœ¨ ORM å±‚å®ç°è½¯åˆ é™¤ï¼Ÿ

**å†³ç­–**: è½¯åˆ é™¤å±äºåº”ç”¨å±‚å…³æ³¨ç‚¹ï¼Œä¸åº”åœ¨ ORM å±‚å®ç°ã€‚

**ç†ç”±**:
1. ORM æœ¬è´¨æ˜¯æ•°æ®æŒä¹…åŒ–å±‚ï¼Œä¸åº”å¼ºåˆ¶ä¸šåŠ¡é€»è¾‘
2. è½¯åˆ é™¤ç­–ç•¥å› ä¸šåŠ¡è€Œå¼‚ï¼ˆdeleted_at vs is_deleted vs statusï¼‰
3. å¼ºåˆ¶å®ç°ä¼šå¢åŠ ä¸€èˆ¬ç”¨æˆ·çš„ä½¿ç”¨è´Ÿæ‹…
4. Ecto ä¹Ÿä¸åœ¨ ORM å±‚å®ç°è½¯åˆ é™¤

**å®ç°æ–¹å¼**:
- eit-cms åº”ç”¨å±‚è‡ªè¡Œå®ç°è½¯åˆ é™¤é€»è¾‘
- eit-db åªéœ€æ”¯æŒåœ¨ Schema ä¸­å®šä¹‰ç›¸å…³å­—æ®µ

### ADR-002: Multiple Adapters æ¶æ„

**å†³ç­–**: æ”¯æŒåŒæ—¶ä½¿ç”¨å¤šä¸ªæ•°æ®æºï¼ˆSQL + æœç´¢å¼•æ“ï¼‰ã€‚

**ç†ç”±**:
1. ç°ä»£åº”ç”¨å¸¸éœ€è¦å…³ç³»å‹æ•°æ®åº“ + æœç´¢å¼•æ“ç»„åˆ
2. æ•°æ®åŒæ­¥æ˜¯å¸¸è§éœ€æ±‚
3. ä¸åŒæ•°æ®æºé€‚åˆä¸åŒåœºæ™¯ï¼ˆPostgreSQL å­˜å‚¨ï¼ŒElasticsearch æœç´¢ï¼‰
4. æ ‡ç­¾å’Œåˆ†ç±»å¯ä»¥é€šè¿‡æœç´¢å¼•æ“çš„èšåˆåŠŸèƒ½å®ç°

**å®ç°æ–¹å¼**:
- ä¸» Adapterï¼ˆSQLï¼‰+ è¾…åŠ© Adaptersï¼ˆæœç´¢å¼•æ“ï¼‰
- å†™å…¥æ—¶å¯é€‰æ‹©åŒæ­¥åˆ°è¾…åŠ© Adapters
- æŸ¥è¯¢æ—¶å¯æŒ‡å®šä½¿ç”¨å“ªä¸ª Adapter

### ADR-003: æ•°æ®ç‰ˆæœ¬æ§åˆ¶åŸºäº Migration

**å†³ç­–**: ä½¿ç”¨ Migration å…ƒæ•°æ®è¡¨å®ç°ç‰ˆæœ¬æ§åˆ¶å’Œè‡ªåŠ¨åˆ†è¡¨ã€‚

**ç†ç”±**:
1. Migration æœ¬èº«å°±æ˜¯ Schema å˜æ›´çš„è®°å½•ç‚¹
2. å¯ä»¥è‡ªåŠ¨ç›‘æ§è¡¨çš„å¢é•¿å’Œç»“æ„å˜åŒ–
3. ç»“åˆç°æœ‰çš„åŠ¨æ€è¡¨åŠŸèƒ½ï¼Œå®ç°è‡ªåŠ¨åˆ†è¡¨
4. ä¸ä¾µå…¥åº”ç”¨å±‚ä»£ç 

**å®ç°æ–¹å¼**:
- `eit_schema_versions` å…ƒæ•°æ®è¡¨
- ç›‘æ§è¡Œæ•°ã€å¤§å°ã€Schema å“ˆå¸Œ
- è¾¾åˆ°é˜ˆå€¼æ—¶è‡ªåŠ¨è§¦å‘åˆ†è¡¨

### ADR-004: æœç´¢å¼•æ“ä½œä¸º Adapter

**å†³ç­–**: å°† Elasticsearchã€Meilisearch ä½œä¸º Adapter å®ç°ã€‚

**ç†ç”±**:
1. æœç´¢å¼•æ“æœ¬è´¨ä¸Šä¹Ÿæ˜¯æ•°æ®å­˜å‚¨
2. ç»Ÿä¸€çš„æ¥å£ä¾¿äºåˆ‡æ¢å’Œæµ‹è¯•
3. å¯ä»¥å¤ç”¨ç°æœ‰çš„ Changeset å’Œäº‹åŠ¡æœºåˆ¶
4. æ”¯æŒæ•°æ®è‡ªåŠ¨åŒæ­¥

**ä¸åŒ…å«çš„åŠŸèƒ½**:
- æ ‡ç­¾å’Œåˆ†ç±»ç³»ç»Ÿï¼ˆåº”ç”¨å±‚å»ºè¡¨å®ç°ï¼Œæˆ–ä½¿ç”¨æœç´¢å¼•æ“èšåˆï¼‰
- å¤æ‚çš„èšåˆåˆ†æï¼ˆç›´æ¥ä½¿ç”¨æœç´¢å¼•æ“å®¢æˆ·ç«¯ï¼‰

### ADR-005: å¤šç§Ÿæˆ·ä¸åœ¨ ORM å±‚å®ç°

**å†³ç­–**: å¤šç§Ÿæˆ·æ¶æ„ç”±åº”ç”¨å±‚æˆ–ä¸“é—¨åº“å¤„ç†ã€‚

**ç†ç”±**:
1. MySQL/SQLiteï¼šç¼ºä¹æ•°æ®åº“çº§éš”ç¦»ï¼Œå¿…é¡»åœ¨åº”ç”¨å±‚å®ç°
2. PostgreSQLï¼šå¯ä½¿ç”¨ Citus æ‰©å±•ï¼Œéœ€è¦ä¸“é—¨é…ç½®
3. SQL Serverï¼šæœ‰å†…ç½®åˆ†å¸ƒå¼æ”¯æŒï¼Œä½†é…ç½®å¤æ‚
4. ä¸åŒæ–¹æ¡ˆå·®å¼‚å¤ªå¤§ï¼ŒORM å±‚ç»Ÿä¸€å¤„ç†ä¼šè¿‡äºå¤æ‚

**å»ºè®®æ–¹æ¡ˆ**:
- è½»é‡çº§åœºæ™¯ï¼šåº”ç”¨å±‚åŠ  tenant_id å­—æ®µ
- ä¼ä¸šçº§åœºæ™¯ï¼šä½¿ç”¨æ•°æ®åº“åŸç”Ÿæ–¹æ¡ˆæˆ–ä¸“é—¨çš„å¤šç§Ÿæˆ·åº“

### ADR-006: åª’ä½“æ–‡ä»¶ç®¡ç†ç‹¬ç«‹

**å†³ç­–**: åª’ä½“æ–‡ä»¶å¤„ç†ä¸åœ¨ eit-db ä¸­å®ç°ï¼Œéœ€è¦ç‹¬ç«‹åº“ã€‚

**ç†ç”±**:
1. æ–‡ä»¶ç®¡ç†ä¸ ORM å…³æ³¨ç‚¹ä¸åŒ
2. æ¶‰åŠæ–‡ä»¶ä¸Šä¼ ã€è½¬ç ã€CDN ç­‰å¤æ‚é€»è¾‘
3. å¯èƒ½éœ€è¦å¯¹æ¥äº‘å­˜å‚¨æœåŠ¡
4. ç‹¬ç«‹åº“æ›´çµæ´»ï¼Œå¯å•ç‹¬æ¼”è¿›

**åä½œæ–¹å¼**:
- æ–‡ä»¶åº“å’Œ eit-db éƒ½è¿æ¥åŒä¸€æ•°æ®åº“
- æ–‡ä»¶åº“ç®¡ç†æ–‡ä»¶ï¼Œeit-db ç®¡ç†å…ƒæ•°æ®è¡¨
- åº”ç”¨å±‚åè°ƒä¸¤è€…çš„ä½¿ç”¨

### ADR-007: æ ‡ç­¾å’Œåˆ†ç±»é€šè¿‡æœç´¢å¼•æ“å®ç°

**å†³ç­–**: æ ‡ç­¾å’Œå…¨æ–‡æœç´¢é€šè¿‡æœç´¢å¼•æ“ Adapter å®ç°ï¼Œè€Œéåœ¨ ORM å±‚æ„å»ºã€‚

**ç†ç”±**:
1. ç°ä»£æœç´¢å¼•æ“ï¼ˆES/Meilisearchï¼‰æä¾›å¼ºå¤§çš„èšåˆå’Œè¿‡æ»¤åŠŸèƒ½
2. æ ‡ç­¾æœ¬è´¨ä¸Šæ˜¯æœç´¢çš„ä¸€ä¸ªç»´åº¦
3. ORM å±‚æ„å»ºæ ‡ç­¾ç³»ç»Ÿè¿‡äºå¤æ‚
4. æœç´¢å¼•æ“çš„æ€§èƒ½è¿œè¶… SQL çš„ LIKE æŸ¥è¯¢

**å®ç°æ–¹å¼**:
- åº”ç”¨å±‚å»ºç«‹æ ‡ç­¾è¡¨ï¼ˆç®€å•çš„ id, name, slugï¼‰
- æ–‡ç« æ•°æ®åŒæ­¥åˆ° Elasticsearch æ—¶åŒ…å«æ ‡ç­¾ä¿¡æ¯
- ä½¿ç”¨ ES çš„ terms èšåˆå’Œè¿‡æ»¤å®ç°æ ‡ç­¾æŸ¥è¯¢
- åˆ†ç±»ç³»ç»Ÿç±»ä¼¼ï¼Œä½¿ç”¨ nested æˆ– parent-child å…³ç³»
